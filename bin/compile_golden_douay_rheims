#! /usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use File::Copy;
use File::Slurp;
use Getopt::Long;
use IPC::Run3;
use String::Diff qw( diff );
use String::ShellQuote;
use String::Trim;
use Text::Capitalize;
use YAML;
use utf8;

use feature 'say';

# binmode STDOUT, ":raw";
# binmode *STDOUT, ':utf8';

require "./sources/lib/perl5/shared.pl";

my $book_order_file = './etc/book_order.yaml';
my $top_out_dir = "./library";
my $golden_out_dir = "$top_out_dir/golden-douay-rheims";

my %source_dirs = (
    'johnblood' => './sources/johnblood_haydock/out',
    'pg1581'            => './sources/pg1581/out',
    'drbo'              => './sources/drbo/out',
    'cbol'              => './sources/cbol_douay-rheims/out',
    'vulsearch'         => './sources/vulsearch_vulgate/out',
    'pg8300_info'       => './sources/pg8300/etc/by_id.yaml',
    'vscodes_count'     => './sources/vulsearch_vulgate/out_vscode_counts',
    'match_of_drbo_or_pg1581' => './etc/diff_sheets',
);

my %programs = (
    'check_match_drbo_or_pg1581' => './bin/check_diff_sheet'
);


my $drbo_dir = $source_dirs{drbo};
my $pg1581_dir = $source_dirs{pg1581};


my $choices = {};
my @books = book_list($book_order_file, qw( OT NT ));


for my $book_id (@books) {
    next unless book_has_red_letters($book_id);

    say '#'x70;
    #say "# $book_id";

    my $pg1581 = read_source_book($pg1581_dir, $book_id);
    my $drbo   = read_source_book($drbo_dir, $book_id);
    my $out_file = "$golden_out_dir/$book_id.yaml";
    my @chapter_list = (combined_keys($drbo->{chapters}, $pg1581->{chapters}));

    check_match_drbo_or_pg1581($book_id);

    my $book = {
        book_id => $book_id,
        titles => {},
        chapters => {},
        intro => {},
    };

    load_book_info_from_pg1581($book, $pg1581);

    for my $c_index (@chapter_list) {
        #say "   C: $c_index";
        load_chap_intro_from_pg1581($book, $pg1581, $c_index);
        load_verses_from_pg1581($book, $pg1581, $c_index);
        overlay_TAN_match_of_drbo_or_pg1581($book, $c_index, $drbo, $pg1581);
    }



    #build_chapters($book, $drbo_dir, $pg1581_dir, $book_id);
    #$book->{intro} = fetch_book_field($pg1581_dir, $book_id, 'book_intro');
    #$book->{titles} = get_titles(\%source_dirs, $book_id);

    say "Writing: $out_file";
    YAML::DumpFile($out_file, $book);
}

say "Reenable CP";
#copy_vulsearsh_files($source_dirs{'vulsearch'}, "$top_out_dir/vulsearch_vulgate");

exit(0);


###########################################################################

sub book_yaml_file {
    my ($dir, $book_id) = @_;
    "$dir/$book_id.yaml";
}

sub load_book_info_from_pg1581 {
    my ($book, $pg1581) = @_;

    $book->{intro} = $pg1581->{book_intro};
}


sub load_verses_from_pg1581 {
    my ($book, $pg1581, $c_index) = @_;

    my $chap = $pg1581->{chapters}->{$c_index};
    for my $v_index (sort keys %{$chap->{verses}}) {
        $book->{chapters}->{$c_index}->{verses}->{$v_index} = $chap->{verses}->{$v_index};
    }
}

sub load_chap_intro_from_pg1581 {
    my ($book, $pg1581, $c_index) = @_;

    my $chap = $pg1581->{chapters}->{$c_index};
    $book->{chapters}->{$c_index}->{intro} = $chap->{intro};
}

sub overlay_TAN_match_of_drbo_or_pg1581 {
    my ($book, $c_index, $drbo, $pg1581) = @_;
    my $dir = $source_dirs{'match_of_drbo_or_pg1581'};
    my $file = "$dir/$book->{book_id}.dif";

    my $want_c = $c_index;
    $want_c =~ s/c:0+//;

    #check_match_drbo_or_pg1581($book->{book_id});

    my $last_tag = "";
    my $index = 0;
    my $line_num = 0;
    for my $line (read_file($file)) {
        $line_num++;
        trim($line);

        next if $line =~ /^#/;
        next unless $line =~ /\S/;

        my @cols = split(/\s*\|\s*/, $line);

        if ($cols[0] =~ /^([A-Z1-4][A-Z]{2}):(\d+):(\d+)$/) {
            my ($b,$c,$v) = ($1,$2,$3);
            my $tag = bcv2tag($b,$c,$v);

            next if $c ne $want_c;

            $v =~ s/^0//g;
            $c =~ s/^0//g;
            if ($cols[1] =~ s/^([A-Z]):\s*//) {
                my $letter = $1;
                my $label = $cols[1];
                my $string = $cols[2];
                $index = 0 if $tag ne $last_tag;

                if ($letter eq 'A' || $letter eq 'B') {
                    check_string_in_verse($b,$c,$v, $label, $string, $drbo, $pg1581);
                }
                put_verse_into_choices($b,$c,$v, $index, $letter, $label, $string);

                $last_tag = $tag;
            } elsif ($cols[1] eq 'which') {
                #put_which_into_struct($b,$c,$v, $index, \@cols);
                if ($cols[2] =~ /^1971-Tan:([A-Z_])$/) {
                    my $letter = $1;
                    #say "$tag: $letter -- "; ##. Dumper($choices);

                    check_choices($book, $choices, $drbo, $pg1581, $b, $c, $v, $index, $tag);

                    if ($letter eq 'A') {
                        #confirm_match($book, $choices, $b, $c, $v, $index, $tag,  'A');
                        replace_with('A')
                    } elsif ($letter eq 'B') {
                        #confirm_match($book, $choices, $b, $c, $v, $index, $tag,  'B');
                    } elsif ($letter eq 'C') {
                        replace_with('C');
                        #say Dumper($choices);
                    } elsif ($letter eq 'D') {
                        replace_with('D');
                        #say Dumper($choices);
                    } elsif ($letter eq 'Z') {
                        #say Dumper($choices);
                    } elsif ($letter eq '_') {
                        1;
                    } else {
                        die "$tag: Unknown letter: $letter\n";
                    }
                } else {
                    die "$tag: Unknown which: no 1971-Tan -- $cols[2]\n";
                }
                $choices = {};
                $index++;
            }
        }
    }
}


sub bcv2tag {
    my ($book_id, $c, $v) = @_;
    $c =~ s/^c://;
    $v =~ s/^v://;
    sprintf("%s:%02d:%02d", $book_id, $c, $v);
}

sub OLD_bcv_tag {
    my ($b,$c,$v) = @_;

    sprintf("%3s:%d:%d", $b, $c, $v);
}

sub check_match_drbo_or_pg1581 {
    my ($book_id) = @_;

    my $pgm = $programs{check_match_drbo_or_pg1581};
    run_cmd({}, $pgm, $book_id);


}


sub check_choices {
    my ($book, $choices, $drbo, $pg1581, $b, $c, $v, $index, $tag) = @_;

    my $c_index = sprintf("c:%03d", $c);
    my $v_index = sprintf("v:%03d", $v);

    for my $field (qw( b c v index tag)) {
        my $value = eval("\$$field");
        my $in_choices = $choices->{$field};
        if ($value ne $in_choices) {
            die "Check_choices mismatch: $field --  '$value' ne '$in_choices', Stopped";
        }
    }

    #say Dumper($drbo->{chapters}->{$c_index}->{verses}->{$v_index});

    my @drbo_vals = split(/\s*\|\s*/, $drbo->{chapters}->{$c_index}->{verses}->{$v_index});
    my @pg1581_vals = split(/\s*\|\s*/, $pg1581->{chapters}->{$c_index}->{verses}->{$v_index});

    my $drbo_count   = match_count($choices->{letters}->{A}, $drbo_vals[3]);
    my $pg1581_count = match_count($choices->{letters}->{B}, $pg1581_vals[3]);

    die "$tag NO_MATCH A in DRBO:       | $choices->{letters}->{A} | $drbo_vals[3] |  Stopped"   if $drbo_count   == 0;
    die "$tag NO_MATCH B in PG1581:     | $choices->{letters}->{B} | $pg1581_vals[3] |  Stopped" if $pg1581_count == 0;
    die "$tag MULTI_MATCHS A in DRBO:   | $choices->{letters}->{A} | $drbo_vals[3] |  Stopped"   if $drbo_count   != 1;
    die "$tag MULTI_MATCHS B in PG1581: | $choices->{letters}->{B} | $pg1581_vals[3] |  Stopped" if $pg1581_count != 1;
    #say ">>>>  $drbo_vals[3]";

    #say "--- $tag ---";
    for my $let (sort keys %{$choices->{letters}}) {
        next if $let eq 'A' || $let eq 'B';
        my $A_val = $choices->{letters}->{A};
        my $B_val = $choices->{letters}->{B};
        my $val = $choices->{letters}->{$let};
        die "$tag $let eq A | $val | $A_val | Stopped" if $val eq $A_val;
        die "$tag $let eq B | $val | $B_val | Stopped" if $val eq $B_val;
        die "$tag $let actually in drbo | $val | $drbo_vals[3]\n"    if match_count($val, $drbo_vals[3]);
        die "$tag $let actually in drbo | $val | $pg1581_vals[3]\n"  if match_count($val, $pg1581_vals[3]);
    }

}


sub match_count {
    my ($regex, $string) = @_;

    $regex =~ s/\?/\\?/g;
    $regex =~ s/\./\\./g;
    $regex =~ s/\(/\\(/g;
    $regex =~ s/\)/\\)/g;

    my $count = () = $string =~ m{$regex}g;

    #say "MATCH COUNT $count | $regex | $string |";

    $count;
}

sub confirm_match {
    my ($letter) = @_;

}

sub  replace_with {
    my ($letter) = @_;

}

sub read_source_book {
    my ($dir, $book_id) = @_;
    my $out = load_yaml_file("$dir/$book_id.yaml");

    $out;
}


sub OLD_build_chapters {
    my ($book, $drbo_dir, $pg1581_dir, $book_id) = @_;
    my $drbo_file =   "$drbo_dir/$book_id.yaml";
    my $pg1581_file = "$pg1581_dir/$book_id.yaml";
    my $vscodes_count_file = "$source_dirs{vscodes_count}/$book_id.yaml";

    my $footnote_fixes = load_yaml_file('./etc/footnote_fixes.yaml');
    my $red_letter_map = {};
    if (book_has_red_letters($book_id)) {
        $red_letter_map  = load_yaml_file("./etc/red_letters/$book_id.yaml");
    }

    say "########################################################";
    say "# Processing: $book_id";
    say "########################################################";

    die "No such directory: $drbo_dir" unless -d $drbo_dir;
    die "No such directory: $pg1581_dir" unless -d $pg1581_dir;
    die "No_such_file: $drbo_file\n" unless -f $drbo_file;
    die "No_such_file: $pg1581_file\n" unless -f $pg1581_file;

    my $drbo_data     = load_yaml_file($drbo_file);
    my $pg1581_data   = load_yaml_file($pg1581_file);
    my $vscodes_count = load_yaml_file($vscodes_count_file);

    for my $c_index (combined_keys($drbo_data->{chapters}, $pg1581_data->{chapters})) {
        my $c_tag = num_to_tag('c', $book_id, $c_index);

        my $drbo_chap   = $drbo_data->{chapters}->{$c_index};
        my $pg1581_chap = $pg1581_data->{chapters}->{$c_index};

        $book->{chapters}->{$c_index} = { 'verses' => {} };
        my $chap_out = $book->{chapters}->{$c_index};

        $chap_out->{intro} = $pg1581_chap->{intro};
        $chap_out->{footnotes} = {};

        for my $v_index (combined_keys($drbo_chap->{verses}, $pg1581_chap->{verses})) {
            my $v_num = tag_to_num($v_index);
            my $v_tag = num_to_tag('v', $c_tag, $v_num);
            my $drbo_vers   = $drbo_chap->{verses}->{$v_index};
            my $pg1581_vers = $pg1581_chap->{verses}->{$v_index};

            if (!defined($drbo_vers) || $drbo_vers eq '') {
                die "Only in $pg1581_file: $v_tag\n";
                next;
            }
            if (!defined($pg1581_vers) || $pg1581_vers eq '') {
                die "Only in $drbo_file: $v_tag\n";
                next;
            }

            my ($pg1581_tag, $pg1581_v, $pg1581_dis, $pg1581_text) = split(/\s*\|\s*/, $pg1581_vers);
            my ($drbo_tag,   $drbo_v,   $drbo_dis,   $drbo_text)   = split(/\s*\|\s*/, $drbo_vers);

            die "Error: drbo_tag & v_tag don't match: '$drbo_tag' != '$v_tag'\n" if $drbo_tag   ne $v_tag;
            die "Error: pg1581_tag & v_tag don't match: '$pg1581_tag' != '$v_tag'\n" if $pg1581_tag ne $v_tag;
            die "Error: drbo_v & v_num don't match: '$drbo_v' != '$v_num'\n" if $drbo_v ne $v_num;
            die "Error: pg1581_v & v_num don't match: '$pg1581_v' != '$v_num'\n" if $pg1581_v ne $v_num;

            my $display_v = choose_display_v($v_tag, $v_num, $drbo_dis, $pg1581_dis);
            my $text = choose_verse_text($v_tag, $drbo_text, $pg1581_text);

            if (defined($drbo_chap->{footnotes}->{$v_index}) || defined($pg1581_chap->{footnotes}->{$v_index})) {
                $chap_out->{footnotes}->{$v_index} = choose_footnotes($v_tag, $v_index, $drbo_chap, $pg1581_chap, $footnote_fixes);
                $text = make_footnote_tags($chap_out, $v_tag, $v_index, $text);
            }

            if (book_has_red_letters($book_id)) {
                $text = apply_redletters($v_tag, $text, $red_letter_map);
            }
            $text = apply_vscodes($text, $vscodes_count, $c_index, $v_index);

            my $entry = join(' | ', $v_tag, $v_num, $display_v, $text);
            $chap_out->{verses}->{$v_index} = $entry;

        }
    }
}

sub make_footnote_tags {
    my ($chap, $v_tag, $v_index, $text) = @_;
    my $index=0;
    return $text if $chap->{footnotes}->{$v_index} eq "";
    for my $entry (@{$chap->{footnotes}->{$v_index}}) {
        my $match = $entry->{match};
        if ($text =~ s/($match)/\{FOOTNOTE:BEGIN $index}$1\{FOOTNOTE:END\}/i) {
            $chap->{verses}->{$v_index} = $text;
        } else {
            say "FIX_FOOTNOTE:\n  $v_tag:\n    $index:\n      match: ''  # was '$match' -- $text\n";
        }
        $index++;
    }

    $text
}



sub apply_vscodes {
    my ($text, $vscodes_count, $c_index, $v_index) = @_;
    my $counts = $vscodes_count->{chapters}->{$c_index}->{verses}->{$v_index};
    if (defined $counts) {
        $text .= '{VS:P}'  if $counts->{ending_p};
        $text .= '{VS:BR}' if $counts->{ending_br};
        $text .= '{VS:VERSE:END}' if $counts->{ending_verseend};
        $text .= '{VS:VERSE:END}{VS:P}' if $counts->{ending_verseend_p};
        $text = "{VS:VERSE:BEGIN}$text" if $counts->{beginning_versebegin};
    }

    $text
}

sub apply_redletters {
    my ($v_tag, $text, $map) = @_;

    my $tag = $v_tag;
    $tag =~ s/^[A-Z]{3}://;

    if (my $rule = $map->{$tag}) {
        trim($rule);

        if ($rule eq 'ALL') {
            $text = "{RED:BEGIN}${text}{RED:END}";
        } elsif ($rule =~ /^(.+)\s+\.\.\.$/) {
            my $quote=$1;
            trim($quote);
            die "$tag: Multiple red_letter quotes, Stopped" if $quote =~ /\.\.\./;
            $text =~ s/($quote.*)$/\{RED:BEGIN}$1\{RED:END}/i
                || warn "$v_tag: Failed to apply red_letters | rule = $rule | text = $text |";
        } elsif ($rule =~ /^\.\.\.\s+(.+)$/) {
            my $quote=$1;
            trim($quote);
            die "$tag: Multiple red_letter quotes, Stopped" if $quote =~ /\.\.\./;
            $text =~ s/^(.+$quote)/\{RED:BEGIN}$1\{RED:END}/i
                || warn "$v_tag: Failed to apply red_letters | rule = $rule | text = $text |";
        } elsif ($rule =~  /^(.+\S)\s\.\.\.\s(\S.+)$/) {
            my ($begin, $end) = ($1, $2);
            trim($begin);
            trim($end);
            die "$v_tag: Multiple red_letter quotes, Stopped" if $begin =~ /\.\.\./;
            die "$v_tag: Multiple red_letter quotes, Stopped" if $end =~ /\.\.\./;
            $text =~ s/\s(${begin}\s.+\s${end})\s/ \{RED:BEGIN}$1\{RED:END} /i
                || warn "$v_tag: Failed to apply red_letters | rule = $rule | text = $text |";
        } else {
            my $quote = $rule;
            trim($quote);
            die "$v_tag: Multiple red_letter quotes, Stopped" if $quote =~ /\.\.\./;
            $text =~ s/($quote)/\{RED:BEGIN}$1\{RED:END}/i 
                || warn "$v_tag: Failed to apply red_letters | rule = $rule | text = $text |";
        }
    }

    $text;
}

sub book_has_red_letters {
    my ($book_id) = @_;
    grep(/^$book_id$/, (qw( MAT MRK LUK JHN ACT 1CO 2CO REV )));
}

sub choose_display_v {
    my ($v_tag, $v_num, $drbo_dis, $pg1581_dis) = @_;


    #TODO: use some logic

    $pg1581_dis;
}

sub choose_verse_text {
    my ($v_tag, $drbo_text, $pg1581_text) = @_;
    #TODO: use some logic

    $pg1581_text;
}

sub choose_footnotes {
    my ($v_tag, $v_index, $drbo_chap, $pg1581_chap, $footnote_fixes) = @_;
    my @out = ();
    #TODO: use some logic

    my $drbo_footnotes = $drbo_chap->{footnotes}->{$v_index};
    my $pg1581_footnotes = $pg1581_chap->{footnotes}->{$v_index};

    if (defined($drbo_footnotes)) {
        return format_footnotes($v_tag, $drbo_footnotes, $footnote_fixes);
    }
}

sub format_footnotes {
    my ($v_tag, $footnotes_for_verse, $footnote_fixes) = @_;
    my @out = ();

    my $i=0;
    for my $e (@{$footnotes_for_verse}) {
        $e->{match} = lc($e->{'quote'});
        if (defined(my $f = $footnote_fixes->{$v_tag}->{$i})) {
            $e->{match} = lc($f->{match}) if defined($f->{match});
        }
        push(@out, $e);
        $i++;
    }
    \@out;
}

sub copy_vulsearsh_files {
    my ($in_dir, $out_dir) = @_;
    print "Copying VulSearch (Vulgate) files:\n";
    for my $file (read_dir($in_dir)) {
        my $from_file = "$in_dir/$file";
        my $to_file = "$out_dir/$file";
        print "  CP $from_file  $to_file\n";
        copy($from_file, $to_file);
    }
    print "\n";
}

sub tag_to_num {
    my ($tag) = @_;
    $tag =~ s/^.+://;
    $tag =~ s/^0+//;

    $tag
}

sub get_titles {
    my ($source_dirs, $book_id) = @_;
    my $titles = {};
    my $names = {};

    for my $src (qw( cbol drbo pg1581 johnblood )) {
        my $title = fetch_book_field($source_dirs->{$src}, $book_id, 'book_title');
        if ($src eq 'pg1581' || $src eq 'johnblood') {
            $title = capitalize_title($title);
        }
        $titles->{$src} = $title;
    }
    {
        my $pg8300 = load_yaml_file($source_dirs->{'pg8300_info'});
        $titles->{pg8300} = $pg8300->{$book_id}->{title};
        $titles->{'pg8300_short'} = $pg8300->{$book_id}->{short};
    }
    $titles->{'cbol_abv'} = fetch_book_field($source_dirs->{'cbol'}, $book_id, 'book_abv');

    $titles
}

sub fetch_book_field {
    my ($dir, $book_id, $field) = @_;

    my $file_name = book_yaml_file($dir, $book_id);
    #say "LOADING: $file_name FIELD: $field\n";
    my $data = load_yaml_file($file_name);
    $data->{$field};
}

sub load_yaml_file {
    my ($file) = @_;

    print "Opening YAML file: $file\n";
    YAML::LoadFile($file)
}

sub run_cmd {
    my ($args, @cmd) = @_;

    my $cmd_str = shell_quote(@cmd);

    say "Running: $cmd_str";
    system(@cmd);

    if ($? == -1) { # Failed to start program / error of the wait(2) system call
        die "Failed to execute '$cmd_str': $!";
    } elsif ($? & 127) { # Check for non-zero signal
        die "'$cmd_str' died with signal", ($? & 127), ($? & 128) ? 'with' : 'without', " coredump";
    } else { # No kill signal, check exit code.
        my $exit_code = $? >> 8; # This is the number you said to be 255.
        # print "'$runCmd' exited with value ", $exit_code, "\n";

        if ($exit_code == 255) {
            die("Failed to run \"$cmd_str\": $!");
        } elsif ($exit_code != 0) {
            die "\"$cmd_str\" exited with exit code: $exit_code\n";
        }
    }
}

sub check_string_in_verse {
    my ($b,$c, $v, $label, $string, $drbo, $pg1581) = @_;
    my $c_index = "c:".num_to_3digits($c);
    my $v_index = "v:".num_to_3digits($v);

    my $const_label = sprintf("%-6s", $label);

    my $tag = "$b:$c:$v";
    $tag = bcv2tag($b,$c,$v);

    my $entry='';
    if ($label eq 'drbo') {
        $entry = $drbo->{chapters}->{$c_index}->{verses}->{$v_index};
    } elsif ($label eq 'pg1581') {
        $entry = $pg1581->{chapters}->{$c_index}->{verses}->{$v_index};
    } elsif ($label eq '1971-tan') {
        return;
    } elsif ($label eq '1899-murphy') {
        return;
    # } else {
    #     print ":::: $line\n";
    }

    die "$const_label $tag | NOMATCH: | $c_index $v_index | $string \n"
        unless defined($entry);

    my($e_tag, $e_chap, $e_c_display, $e_text) = split(/\s*\|\s*/, $entry);
    #say "$tag | $c_index $v_index | $e_tag | $string | $e_text\n";


    my $regex = $string;
    $regex =~ s/\?/\\?/g;
    $regex =~ s/\./\\./g;
    $regex =~ s/\(/\\(/g;
    $regex =~ s/\)/\\)/g;

    my $matches = () = $e_text =~ m{$regex}g;

    #say "$tag == MATCHES: $matches | $string | $e_text";

    if ($string =~ / \.\.\. /) {
        die "$tag $const_label  NEED_TO_SPLIT | $string\n";
    } elsif ($matches > 1) {
        die "$tag $const_label  MULTIPLE MATCHES OF | $string | $e_text\n";
    } elsif ($matches != 1) {
        die "$tag $const_label  NO MATCHES OF | $string | $e_text\n";
    }
}

sub put_verse_into_choices {
    my ($b,$c,$v, $index, $letter, $label, $string) = @_;
    my $c_index = "c:".num_to_3digits($c);
    my $v_index = "v:".num_to_3digits($v);
    my $tag = bcv2tag($b,$c,$v);

    if (int(%$choices)) {
        for my $field (qw( b c v index tag )) {
            my $value = eval("\$$field");
            my $in_choices = $choices->{$field};
            if ($value ne $in_choices) {
                die "Mismatch in choices: $field -- '$value' ne '$in_choices', Stopped";
            }
        }
    } else {
        for my $field (qw( b c v index tag )) {
            my $value = eval("\$$field");
            $choices->{$field} = $value;
        }
    }

    if (defined($choices->{letters}->{$letter})) {
        die "Letter $letter already defined, Stopped";
    }

    $choices->{letters}->{$letter} = $string;
}
