#! /usr/bin/env perl

use strict;
use warnings;

use File::Slurp;
use String::Trim;
use YAML;

require "./sources/lib/perl5/shared.pl";

use feature 'say';


my $usage = "Usage: $0 book_id\n";
my $book_id = shift() || die $usage;

my $diff_file = "./etc/diff_sheets/$book_id.dif";
my $drbo_file = "./sources/drbo/out/$book_id.yaml";
my $pg1581_file = "./sources/pg1581/out/$book_id.yaml";

my $drbo   = YAML::LoadFile($drbo_file);
my $pg1581 = YAML::LoadFile($pg1581_file);

my $line_num = 0;
for my $line (read_file($diff_file)) {
    $line_num++;
    trim($line);
    next if $line =~ /^#/;
    next unless $line =~ /\S/;
    my @cols = split(/\s*\|\s*/, $line);
    my ($b,$v,$c);
    if ($cols[0] =~ /^([A-Z1-4][A-Z]{2}):(\d+):(\d+)$/) {
        ($b,$c,$v) = ($1,$2,$3);
        $v =~ s/^0//g;
        $c =~ s/^0//g;
        if ($cols[1] =~ s/^([A-Z]):\s*//) {
            my $letter = $1;
            my $label = $cols[1];
            my $string = $cols[2];

            if (!defined($cols[2])) {
                say "$label $book_id:$c:$v UNDEF_STRING";
                next;
            }

            #next if !defined($string) || $string eq ''; 
            if ($string eq '') {
                say "$label $book_id:$c:$v EMPTY_STRING";
                next;
            } elsif (!defined($string)) {
                say "$label $book_id:$c:$v UNDEF2_STRING";
                next;
            }

            check_letter_label($diff_file, $line_num, $letter, $label);
            check_string_in_verse($b,$c,$v, $label, $string);

        } elsif ($cols[1] eq 'which') {
           1;
        } else {
            say "??? $line";
        }
    } else {
        say "$cols[0]";
        die "${diff_file}[$line_num]: ODD_LINE: $line\n";
    }
    #print "$line\n";

    #exit if $line_num >= 10;
}

sub check_string_in_verse {
    my ($b,$c, $v, $label, $string) = @_;
    my $c_index = "c:".num_to_3digits($c);
    my $v_index = "v:".num_to_3digits($v);

    my $const_label = sprintf("%-6s", $label);

    my $tag = "$b:$c:$v";

    my $entry='';
    if ($label eq 'drbo') {
        $entry = $drbo->{chapters}->{$c_index}->{verses}->{$v_index};
    } elsif ($label eq 'pg1581') {
        $entry = $pg1581->{chapters}->{$c_index}->{verses}->{$v_index};
    # } else {
    #     print ":::: $line\n";
    }

    die "$const_label $tag | NOMATCH: | $c_index $v_index | $string \n"
        unless defined($entry);

    my($e_tag, $e_chap, $e_c_display, $e_text) = split(/\s*\|\s*/, $entry);
    #say "$tag | $c_index $v_index | $e_tag | $string | $e_text\n";


    my $regex = $string;
    $regex =~ s/\?/\\?/g;
    $regex =~ s/\./\\./g;
    $regex =~ s/\(/\\(/g;
    $regex =~ s/\)/\\)/g;

    my $matches = () = $e_text =~ m{$regex};
    #say "$matches | $tag | $string | $e_text"
    #say "$b:$c:$v  -- $string";

    if ($string =~ / \.\.\. /) {
        say "$const_label  $tag NEED_TO_SPLIT | $string";
    } elsif ($matches > 1) {
        say "$const_label $tag MULTIPLE MATCHES OF | $string | $e_text";
    } elsif ($matches != 1) {
        say  "$const_label $tag NO MATCHES OF | $string | $e_text";
    }



}

sub check_letter_label {
    my ($file, $line_num, $letter, $label) = @_;

    die "${file}[$line_num]: ODD LETTER LABEL: $letter: $label\n" 
        if $letter eq 'A' && $label ne 'drbo';
    die "${file}[$line_num]: ODD LETTER LABEL: $letter: $label\n" 
        if $letter eq 'B' && $label ne 'pg1581';

    die "${file}[$line_num]: ODD LETTER LABEL: $letter: $label\n" 
        if $letter ne 'A' && $label =~ /drbo/i;
    die "${file}[$line_num]: ODD LETTER LABEL: $letter: $label\n" 
        if $letter ne 'B' && $label =~ /1581/i;

    #print "$letter: $label\n" unless $letter eq 'A' || $letter eq 'B';

}

