#! /usr/bin/perl

use strict;
use warnings;

use Data::Dumper;
use Encode;
use File::Basename;
use File::Path qw(make_path);
use File::Slurp;
use Getopt::Long;
use JSON;
use utf8;
use YAML qw( Load LoadFile );
use YAML::Safe;

use open ':encoding(utf8)';
use open ':std';


my $strip = 0; 

GetOptions (
    "strip"  => \$strip,
)  || die("Error in command line arguments\n");


my @bibles = (qw( douay_rheims knox vulgate ));
my @parts  = (qw( OT NT ));
my $book_id = YAML::LoadFile("./book_ids.yaml");

my $top_in_dir = './downloaded';
my $top_out_dir = '/Users/thomaslink/src/github.com/tomazon/vulbibgen/vulbibgen/data/bibles';
my %out_dir = (
    douay_rheims => "$top_out_dir/douay_rheims_1",
    knox         => "$top_out_dir/knox_1",
    vulgate      => "$top_out_dir/vulgate_1",
);

my $file = shift();
if ($file) {
    my $data = parse_verse_file($file);
    print YAML::Safe::Dump($data);
    exit();
}

for my $bible (@bibles) {
    my $out_bible_dir =  $out_dir{$bible};
    print "BIBLE: $bible => $out_bible_dir\n";
    unless (-d $out_bible_dir) {
        mkdir ($out_bible_dir) || die "Can't mkdir $out_bible_dir: $!\n";
    }
    for my $part (@parts) {
        my $in_parts_dir = "$top_in_dir/$bible/$part";

        for my $in_book (sort (read_dir($in_parts_dir))) {
            my $in_dir = "$in_parts_dir/$in_book";
            my $id = $book_id->{'USFM_names'}->{$bible}->{$in_book}
              || die "Can't find USFM ID for $bible/$in_book\n";
            # my $out_dir = "$out_bible_dir/$id";
            # if (! -d $out_dir) {
            #     mkdir($out_dir) || die "Can't mkdir $out_dir: $!\n";
            # }
            #print "B      $in_dir  => $id\n";

            print "    Processing $bible $id from $in_dir\n";

            my $out_file = "$out_bible_dir/$id.yaml";
            my $data = {};
            $data->{book} = $id;
            for my $file (sort _by_ch (read_dir($in_dir))) {
                my $in_file = "$in_dir/$file";
                print "        Reading: $in_file\n";
                if ($file =~ m/ch_(\d+)$/) {
                    if (-f "$in_file.MADE_UTF8") {
                        $in_file = "$in_file.MADE_UTF8";
                    }
                    my $chapter_num = $1;
                    # my $out_file = sprintf("$out_dir/%03d.yaml", $chapter_num);
                    # print "$in_file  => $out_file\n";


                    my $chap_data = parse_verse_file($in_file, $chapter_num, $id);
                    $chap_data = final_processing($chap_data, $bible, $id);

                    $data->{bible_name} = $chap_data->{bible_name};
                    $data->{book_name}  = $chap_data->{book_name};

                    delete($chap_data->{bible_id});
                    delete($chap_data->{book_id});
                    delete($chap_data->{bible_name});
                    delete($chap_data->{book_name});


                    $data->{chapters}->[$chapter_num] = $chap_data;
                    #YAML::Safe::DumpFile($out_file, $data);

                    $data->{chapter_count} = $chapter_num;
                    

                } else {
                    #die "ODD_FILE_NAME: $in_file\n";
                }
            }
            print "        Writing: $out_file\n";
            YAML::Safe::DumpFile($out_file, $data);
        }
    }
}

sub final_processing {
    my ($data, $bible, $book_code) = @_;

    $data->{book_id}  = $book_code;
    $data->{bible_id} = "${bible}_1";
    if ($bible eq 'knox') {
        if ($book_code eq 'JOB') {
            $data->{verses}->[9] =~ s{\*}{<comment=2>};
                #s{\*}{<a href="" class="inline-comment" data-comment-id="822">*</a>};
            $data->{comments}->{2}->{verse_number} = 9;
        } elsif ($book_code eq '2MA') {
            $data->{verses}->[10] =~ s{\*}{<comment=4>};
            $data->{comments}->{4}->{verse_number} = 10;

        }
    }

    if (defined($data->{verses}->[0]) && $data->{verses}->[0] =~ /\S/) {
        my $verse_0 = $data->{verses}->[0];
        my $verse_1 = $data->{verses}->[1];

        $verse_0 =~ s/\@//;
        $verse_0 =~ s{[\s/]+$}{};
        $verse_0 =~ s/^([A-Z0-4]{3}\:\d{1,3})\:0 /${1}:1 /;

        $verse_1 =~ s/^[A-Z0-4]{3}\:\d{1,3}\:1 //;

        $data->{verses}->[1] = "$verse_0 [$verse_1";
        delete ($data->{verses}->[0]);
    } elsif (defined($data->{verses}->[2]) && $data->{verses}->[2] =~ /:2 @/) {
        $data->{verses}->[1] =~ s/:1 @/:1 /;
        $data->{verses}->[2] =~ s/:2 @/:2 /;
        $data->{verses}->[3] =~ s/:3 /:3 [/;
    } elsif (defined($data->{verses}->[1]) && $data->{verses}->[1] =~ /:1 @/) {
        $data->{verses}->[1] =~ s/:1 @/:1 /;
        $data->{verses}->[2] =~ s/:2 /:2 [/;
    }

    #TODO: reactivate this
    # for my $verse_num (0..$data->{last_verse_number}) {
    #     if (my $hash = $data->{verses}->[$verse_num]->{comments}) {
    #         for my $comment_num (sort {$a<=>$b} (keys %{$hash})) {
    #             $data->{comments}->{$comment_num}->{verse_num} = $verse_num;
    #         }
    #         delete($data->{verses}->[$verse_num]->{comments});
    #         #print "!!!!!!! $id -- $num\n";
    #     }
    # }

    # if (defined ($data->{'verses'}->[0]->{'content'})) {
    #     $data->{meta}->{'verse_zero_has_content'} = 'true';
    # }



    $data;
}

sub clean {
    my ($str) = @_;

    $str =~ s/^\s+//g;
    $str =~ s/\s+$//g;
    $str =~ s/\s+/ /g;

    $str;
}

sub _by_ch {
    my ($A, $B) = ($a,$b);
    $A =~ s/^ch_//;
    $B =~ s/^ch_//;

    if ($A =~ /\.PATCHED/ || $B =~ /\.PATCHED/ || $A =~ /\.MADE_UTF8/ || $B =~ /.MADE_UTF8/) {
        return($A cmp $B)
    }
    ($A <=> $B);
}

sub parse_verse_file {
    my ($file, $chapter_num, $book_code) = @_;
    my $content = read_file($file, { binmode => ':utf8' });
    # $content = decode 'utf-8', $content, 1;
    # $content = encode 'utf-8', $content, 1;
    $content =~ s{<header.+</header>}{}s;
    $content =~ s{^.+<!-- END WAYBACK TOOLBAR INSERT -->}{}s;
    $content =~ s{https://web.archive.org/web/20220816031714/}{}g;
    #$content =~ s{<div class="chapters">.+</div>}{}is;
    $content =~ s{<ul .+</ul>}{}sg;
    $content =~ s/\x{273B}/*/g;  # unicode tear drop start to ASCII star
    $content =~ s{\n+</div>}{</div>}g;
    my %comment_map = ();

    # print "$content\n";    return();

    my $out = {};
    #$out->{source_file} = $file;
    $out->{chapter_num} = $chapter_num;
    my $state = '';
    my $acc = '';
    for my $line (split(/\n/, $content)) {
        chomp($line);
        #$line = decode('utf8', $line);

        if ($state eq '') {
            if ($line =~ /<SCRIPT>/i) {
                $state = 'SCRIPT';
                next;
            } elsif ($line =~ /<div id="(\w+)" class="vers">/) {
                $acc = {};
                $acc = $1;
                $state = 'VERSE_NUM';
            } elsif ($line =~ /<div id="(\w+)" class="vers vers-inline">/) {
                $acc = {};
                $acc = $1;
                $state = 'VERSE_NUM';
            } elsif ($line =~ m{<div class="bible-name">(.+)</div>}) {
                $out->{bible_name} = clean($1);
            } elsif ($line =~ m{<div class="book-name">(.+)</div>}) {
                $out->{book_name} = clean($1);
            } else {
                1; #print "$line\n";
            }
        } elsif ($state eq 'VERSE_NUM') {
            if ($line =~ m{<div class="vers-no">(\d*)</div>}){
                my $num = $1;
                $num ||= 0;
                my @file_parts = split(m{/}, $file);
                my $bible = $file_parts[2];
                my $path = join('/', @file_parts[3..5]);
                # print STDERR "PATH $path -- $file\n";
                $acc = $num;
                if ($bible eq 'vulgate' || $bible eq 'douay_rheims') {
                     if ($path eq 'OT/Ps/ch_115') {
                         $acc -= 9 if $acc >= 10; # https://catholicbible.online/side_by_side/OT/Ps/ch_115
                         print "ACC: $num -> $acc -- $bible - $path\n";
                     } elsif ($path eq 'OT/Ps/ch_147') {
                         $acc -= 11 if $acc >= 12; # https://catholicbible.online/side_by_side/OT/Ps/ch_147
                         print "ACC: $num -> $acc -- $bible - $path\n";
                     }
                }
            }
            $state = 'VERSE_CONTENT';
        } elsif ($state eq 'VERSE_CONTENT') {
            if ($line =~ m{<div class="vers-content">(.+)</div>}) {
                my $content = $1;
                my $verse_num = $acc;
                my $comment_verse = {};

                ($content, $comment_verse) = parse_verse($content, $acc, \%comment_map);
                $out->{verses}->[$verse_num] = "${book_code}:${chapter_num}:$acc $content";
                $out->{last_verse_number} = $verse_num;
                #print Dumper($out);
                for my $c (sort {$a<=>$b} (keys %{$comment_verse})) {
                    1; 
                    $out->{comments}->{$c}->{verse} = $comment_verse->{$c};
                }
                next;

                #$out->{verses}->[$acc]->{raw_content} = $content;
              #  $out->{verses}->[$acc]->{flags} = {};
                #$content =~ s{</span>}{}g;
                $content =~ s{<span class="content-newline">}{}g;
                if ($content =~ s{<span class="firstverse">}{}) {
                    $out->{verses}->[$acc]->{flags}->{firstverse} = 1;
                    $content =~ s{</span>$}{};
                }



                $content =~ s{<span class="speaker">(.*)</span>}
                             {<speaker>$1</speaker>}g;

                $content =~ s{<a href="" class="inline-comment" data-comment-id="(\d+)">(.*)</a>}
                             {<comment $1>$2</comment>};

                $content =~ s{</span>}{}g;

                $content =~ s/\s+$//;
                $content =~ s/<span class="content-paragraph">/<p>/g;

                # while ($content =~ s/<br>$//) {
                #     $out->{verses}->[$acc]->{flags}->{linebreak_at_end}++;
                # }
                # while ($content =~ s/<p>$//) {
                #     $out->{verses}->[$acc]->{flags}->{paragraph_at_end}++;
                # }
                if ($content =~ s{<br></speaker>$}{</speaker>}) {
                    $out->{verses}->[$acc]->{flags}->{linebreak_at_end}++;
                }

                $out->{verses}->[$acc]->{content} = $content;

            }
            $acc = '';
            $state = '';
        } elsif ($state eq 'SCRIPT') {
            if ($line =~ m{</SCRIPT>}i) {
                $state = '';
                next;
            }
            if ($line =~ /var comments=\{/i) {
                $acc = '';
                $state = 'COMMENTS';
            }
            #print "$line\n";
        } elsif ($state eq 'COMMENTS') {
            if ($line =~ /};/i) {
                $acc =~ s/,\s*$//s;
                $acc = "---\n$acc\n";
                #print "vvv\n$acc\n^^^\n";
                $state = 'SCRIPT';
                $acc = clean_formatting($acc);

                my $orig = YAML::Load($acc);
                #print YAML::Safe::Dump($orig);
                my $new = {};
                my $index=0;
                for my $key (sort {$a<=>$b} (keys %{$orig})) {
                    $index++;
                    $comment_map{$key} = $index;
                    $new->{$index} = $orig->{$key};
                    delete($new->{$index}->{id_comment});
                    delete($new->{$index}->{source_str});
                    $new->{$index}->{caption} = '' if $new->{$index}->{caption} eq '*';
                }
                #print YAML::Safe::Dump($new);
                #exit(0);


                #$out->{comments} = YAML::Load($acc);
                $out->{comments} = $new;
                # print YAML::Safe::Dump($out);
                # exit(0);
            }
            $line =~ s/,\s*$//;
            $line =~ tr/\t/ /;
            $line =~ tr/\{\}//d;
            $line =~ s/^\s+(\d+):/$1:/;
            $acc .= $line ."\n" ;
        } else {
            print "EXTRA: $line\n";
        }
    }
    if ($out->{verses}->[0]) {
        $out->{verse_zero_has_content} = 'true';
    }

    $out->{prefix_verse_count} = 0;

    $out;
}


sub parse_verse {
    my ($content, $num, $comment_map) = @_;
    #my $out = {};
    #$out->{verse_number} = $num;
    my %comment_verse = ();

    ##$content =~ s{✻}{*}g;  # s()() rather than tr()() because char is multi-byte
    # HERE $content =~ s/\x{273B}/*/g;  # unicode tear drop start to ASCII star
    #$content =~ s/\u273B/^/g;
    $content =~ s{<span class="content-newline"><br></span>\s?}{/ }ig;
    $content =~ s{<span class="content-paragraph"><br><br></span>\s?}{\\ }ig;
    $content =~ s{<span class="speaker"><b>([\w\.]+)</b></span>}{<$1>}ig;
    $content =~ s{<span class="speaker">([\w\.]+)\s?</span>}{<$1>}ig;
    $content =~ s{<span class="speaker">(Chorus [\w\.]+)?</span>}{<$1>}ig;
    $content =~ s{<span class="number">17 18</span>\s?}{};
    $content =~ s{<a href="" class="inline-comment" data-comment-id="(\d+)">([^<]+)</a>}{\{[$1] $2\}}ig;

    ##print "COMMENT_MAP: ". YAML::Safe::Dump($comment_map);
    if ($content =~ s|{\[(\d+)\]|"{". $comment_map->{$1}|eg) {
        my $orig_number = $1;
        my $comment_number = $comment_map->{$orig_number};
        #$out->{comments}->{$comment_number}->{verse_number} = $num;
        $comment_verse{$comment_number} = $num;
        $content =~ s[\{(\d+) \*\}][{$1}]g;
        #print ">>>>> $orig_number -- $comment_number -- $num\n";
    }

    $content =~ s{\s+\*>}{>}g;

    $content = clean_formatting($content);

    if ($content =~ s{<span class="firstverse">}{@}) {
        $content =~ s{</span>}{};
        #$content = "#$content";
    }

    ($content, \%comment_verse);
}

sub clean_formatting {
    my ($content) = @_;

    $content =~ s{<P>}{<p>}ig;
    $content =~ s{<B>}{<b>}ig;
    $content =~ s{<I>}{<i>}ig;
    $content =~ s{<br>}{<br>}ig;

    $content =~ s{</P>}{</p>}ig;
    $content =~ s{</B>}{</b>}ig;
    $content =~ s{</I>}{</i>}ig;
    $content =~ s{</br>}{</br>}ig;

    $content =~ s{<br/>}{<br>}ig;
    $content =~ s{<br/\s*>}{<br>}ig;
    $content =~ s{<br\s*/>}{<br>}ig;
    $content =~ s{</br>}{<br>}ig;

    $content =~ s{\\n}{}ig;

    $content =~ s/\s+$//;

    $content;
}
