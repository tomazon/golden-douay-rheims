#! /usr/bin/perl

use strict;
use warnings;

use Data::Dumper;
use Encode;
use File::Basename;
use File::Path qw(make_path);
use File::Slurp;
use File::stat;
use POSIX qw(strftime);
use Getopt::Long;
use JSON;
use utf8;
#use YAML::Safe;
use YAML;

use feature 'say';

use open ':encoding(utf8)';
use open ':std';


my $strip = 0; 
my $book_info_file = 'etc/cbol_douay-rheims.by_file.yaml';
my $in_dir = './downloaded';
my $out_dir = './out';

GetOptions (
    "strip"  => \$strip,
)  || die("Error in command line arguments\n");

my $book_info = YAML::LoadFile($book_info_file);


my %color = (
    red          => "\e[0;31m",
    green        => "\e[0;32m",
    yellow       => "\e[0;33m",
    blue         => "\e[0;34m",
    bright_red   => "\e[1;31m",
    bright_green => "\e[1;32m",
    on_red       => "\e[1;41m",
    on_green     => "\e[1;42m",
    reset        => "\e[0m",
);


my $file = shift();
if ($file) {
    my $data = parse_verse_file($file);
    print YAML::Dump($data);
    exit();
}

my $book = {};

for my $sec (qw( OT NT )) {
    for my $book_dir (sort (read_dir("$in_dir/$sec"))) {
        #print "$book_dir\n";
        write_book_file() if defined($book->{book_id});

        my $book_id = $book_info->{$book_dir}->{USMF_id};
        $book = {
            'book_id'    => $book_id,
            'book_name'  => "",
            'book_title' => "",
            'book_abv'   => "$book_dir",
            'chapters'   => {},
        };

        print "IN $book_id ($book_dir)\n";
        my $dir = "$in_dir/$sec/$book_dir";
        for my $ch (sort _by_chname (read_dir($dir))) {
            next if $ch =~ /\./;
            my $ch_num = $ch;
            $ch_num =~ s/^ch_//;
            $ch .= '.MADE_UTF8' if -f "$dir/$ch.MADE_UTF8";
            my $path = "$dir/$ch";
            print "     Chapter $ch_num ($path)\n";

            my $chap = parse_verse_file($path, $ch_num, $book_id);
            $book->{book_title} ||= $chap->{book_name};
            die "$path: book_name doesn't match\n" if $chap->{book_name} ne $book->{book_title};
            delete($chap->{book_name});
            delete($chap->{bible_name});

            $book->{chapters}->{"c:". num_to_3digits($ch_num)} = $chap;
        }
    }
}
write_book_file();


################################################################################

sub _blue   {$color{blue}   . $_[0] . $color{reset}}
sub _yellow {$color{yellow} . $_[0] . $color{reset}}

sub num_to_3digits {
    sprintf("%03d", $_[0]);
}

sub _by_chname {
    #my ($A, $B) = ($a, $b);
    my ($A, $A_ext) = split(/\./, $a, 2);
    my ($B, $B_ext) = split(/\./, $b, 2);

    #print "$a cmp $b  because $A eq $B\n" if $A eq $B;
    return ($a cmp $b) if $A eq $B;

    $A =~ s/ch_//;
    $B =~ s/ch_//;
    #print " $a <=> $b\n";
    ($A <=> $B)
}

sub write_book_file {
    my $book_id = $book->{book_id};
    my $out_file = "$out_dir/$book_id.yaml";

    print "    $color{blue}Writing: $out_file$color{reset}\n";
    YAML::DumpFile($out_file, $book);
    $book = {};
}

sub parse_verse_file {
    my ($file, $chapter_num, $book_code) = @_;
    my $content = read_file($file, { binmode => ':utf8' });
    $content =~ s/\x{2019}/'/g;  # Right Single Quotation Mark
    # $content = decode 'utf-8', $content, 1;
    # $content = encode 'utf-8', $content, 1;
    $content =~ s{<header.+</header>}{}s;
    $content =~ s{^.+<!-- END WAYBACK TOOLBAR INSERT -->}{}s;
    $content =~ s{https://web.archive.org/web/20220816031714/}{}g;
    #$content =~ s{<div class="chapters">.+</div>}{}is;
    $content =~ s{<ul .+</ul>}{}sg;
    $content =~ s/\x{273B}/*/g;  # unicode tear drop start to ASCII star
    $content =~ s{\n+</div>}{</div>}g;
    my %comment_map = ();

    # print "$content\n";    return();

    my $out = {};
    {
        my $tmp = $file;
        $tmp =~ s{\./downloaded/}{};
        $tmp =~ s/\.MADE_UTF8//; # mtime of original download, not the modified one

        $out->{provenance} = gen_provenance('downloaded', $tmp);
    }
    #$out->{source_file} = $file;
    $out->{chapter_num} = $chapter_num;
    my $state = '';
    my $acc = '';
    for my $line (split(/\n/, $content)) {
        chomp($line);
        #$line = decode('utf8', $line);

        if ($state eq '') {
            if ($line =~ /<SCRIPT>/i) {
                $state = 'SCRIPT';
                next;
            } elsif ($line =~ /<div id="(\w+)" class="vers">/) {
                $acc = {};
                $acc = $1;
                $state = 'VERSE_NUM';
            } elsif ($line =~ /<div id="(\w+)" class="vers vers-inline">/) {
                $acc = {};
                $acc = $1;
                $state = 'VERSE_NUM';
            } elsif ($line =~ m{<div class="bible-name">(.+)</div>}) {
                $out->{bible_name} = clean($1);
            } elsif ($line =~ m{<div class="book-name">(.+)</div>}) {
                $out->{book_name} = clean($1);
            } else {
                1; #print "$line\n";
            }
        } elsif ($state eq 'VERSE_NUM') {
            if ($line =~ m{<div class="vers-no">(\d*)</div>}){
                my $num = $1;
                $num ||= 0;
                my @file_parts = split(m{/}, $file);
                my $bible = $file_parts[2];
                #say "FILE_PARTS: ". join('|', @file_parts);
                my $path = join('/', @file_parts[3..$#file_parts]);
                # print STDERR "PATH $path -- $file\n";
                $acc = $num;
                if ($bible eq 'vulgate' || $bible eq 'douay_rheims') {
                     if ($path eq 'OT/Ps/ch_115') {
                         $acc -= 9 if $acc >= 10; # https://catholicbible.online/side_by_side/OT/Ps/ch_115
                         print "ACC: $num -> $acc -- $bible - $path\n";
                     } elsif ($path eq 'OT/Ps/ch_147') {
                         $acc -= 11 if $acc >= 12; # https://catholicbible.online/side_by_side/OT/Ps/ch_147
                         print "ACC: $num -> $acc -- $bible - $path\n";
                     }
                }
            }
            $state = 'VERSE_CONTENT';
        } elsif ($state eq 'VERSE_CONTENT') {
            if ($line =~ m{<div class="vers-content">(.+)</div>}) {
                my $content = $1;
                my $verse_num = $acc;
                my $comment_verse = {};

                ($content, $comment_verse) = parse_verse($content, $acc, \%comment_map);
                my $entry = join(' | ', "${book_code}:${chapter_num}:$verse_num" , $verse_num, $acc, $content); 
                $out->{verses}->{"v:".num_to_3digits($verse_num)} = $entry;
                $out->{last_verse_number} = $verse_num;
                #print Dumper($out);
                for my $c (sort {$a<=>$b} (keys %{$comment_verse})) {
                    # TODO:  What was this?
                    push(@{$out->{COMMENTS_TMP_C}->{$c}->{"v:".num_to_3digits($verse_num)}}, $comment_verse->{$c});
                    my $tmp = {
                        index => $c,
                    };
                    push(@{$out->{footnotes}->{"v:".num_to_3digits($verse_num)}}, $tmp);
                    #$out->{footnotes}->{"v:".num_to_3digits($verse_num)}->[$c] = $tmp;
                }
                next;

                #$out->{verses}->[$acc]->{raw_content} = $content;
              #  $out->{verses}->[$acc]->{flags} = {};
                #$content =~ s{</span>}{}g;
                $content =~ s{<span class="content-newline">}{}g;
                if ($content =~ s{<span class="firstverse">}{}) {
                    $out->{verses}->[$acc]->{flags}->{firstverse} = 1;
                    $content =~ s{</span>$}{};
                }



                $content =~ s{<span class="speaker">(.*)</span>}
                             {<speaker>$1</speaker>}g;

                $content =~ s{<a href="" class="inline-comment" data-comment-id="(\d+)">(.*)</a>}
                             {<comment $1>$2</comment>};

                $content =~ s{</span>}{}g;

                $content =~ s/\s+$//;
                $content =~ s/<span class="content-paragraph">/<p>/g;

                # while ($content =~ s/<br>$//) {
                #     $out->{verses}->[$acc]->{flags}->{linebreak_at_end}++;
                # }
                # while ($content =~ s/<p>$//) {
                #     $out->{verses}->[$acc]->{flags}->{paragraph_at_end}++;
                # }
                if ($content =~ s{<br></speaker>$}{</speaker>}) {
                    $out->{verses}->[$acc]->{flags}->{linebreak_at_end}++;
                }

                $out->{verses}->[$acc]->{content} = $content;

            }
            $acc = '';
            $state = '';
        } elsif ($state eq 'SCRIPT') {
            if ($line =~ m{</SCRIPT>}i) {
                $state = '';
                next;
            }
            if ($line =~ /var comments=\{/i) {
                $acc = '';
                $state = 'COMMENTS';
            }
            #print "$line\n";
        } elsif ($state eq 'COMMENTS') {
            if ($line =~ /};/i) {
                $acc =~ s/,\s*$//s;
                $acc = "---\n$acc\n";
                #print "vvv\n$acc\n^^^\n";
                $state = 'SCRIPT';
                # print "============================================================\n";
                # print "VVVVVVVV\n";
                # print "$acc\n";
                # print "^^^^^^^^\n";
                $acc = clean_formatting($acc);
                # print "VVVVVVVV\n";
                # print "$acc\n";
                # print "^^^^^^^^\n";

                #say "YAML Loading $acc\n";  
                my $orig = YAML::Load($acc);
                #print YAML::Safe::Dump($orig);
                my $new = {};
                my $index=0;
                for my $key (sort {$a<=>$b} (keys %{$orig})) {
                    $index++;
                    $comment_map{$key} = $index;
                    $new->{$index} = $orig->{$key};
                    delete($new->{$index}->{id_comment});
                    delete($new->{$index}->{source_str});
                    $new->{$index}->{caption} = '' if $new->{$index}->{caption} eq '*';
                }
                #print YAML::Safe::Dump($new);
                #exit(0);


                #$out->{comments} = YAML::Load($acc);
                $out->{COMMENTS_TMP_A} = $new;
                # print YAML::Safe::Dump($out);
                # exit(0);
            }
            $line =~ s/,\s*$//;
            $line =~ tr/\t/ /;
            $line =~ tr/\{\}//d;
            $line =~ s/^\s+(\d+):/$1:/;
            $acc .= $line ."\n" ;
        } else {
            print "EXTRA: $line\n";
        }
    }
    if ($out->{verses}->{"v:000"}) {
        $out->{verse_zero_has_content} = 'true';
    }

    $out->{prefix_verse_count} = 0;

    $out;
}

sub clean_formatting {
    my ($content) = @_;

    $content =~ s{<P>}{<p>}ig;
    $content =~ s{<B>}{<b>}ig;
    $content =~ s{<I>}{<i>}ig;
    $content =~ s{<br>}{<br>}ig;

    $content =~ s{</P>}{</p>}ig;
    $content =~ s{</B>}{</b>}ig;
    $content =~ s{</I>}{</i>}ig;
    $content =~ s{</br>}{</br>}ig;

    $content =~ s{<br/>}{<br>}ig;
    $content =~ s{<br/\s*>}{<br>}ig;
    $content =~ s{<br\s*/>}{<br>}ig;
    $content =~ s{</br>}{<br>}ig;

    $content =~ s{(\S)'(\S)}{$1''$2}g;
    $content =~ s{(\w)' }{$1'' }g;
    $content =~ s{(\s)''\n}{$1'\n}gs;
    $content =~ s{([\w]) '(\S)}{$1 ''$2}g;
    $content =~ s{^(\s+\w+:) '\n}{$1 ''\n}g;
    $content =~ s{  caption: '\n}{  caption: ''\n}g;
    $content =~ s{caption: '+T is well.'?}{caption: "'T is well.'"}g;
    $content =~ s{'''T is well[,\.]? 't is well'\n}{"'T is well$1'"\n}g;
    $content =~ s{"'T is well.'" 't is well'\n}{"'T is well.'"\n}g;

    $content =~ s{\\n}{}ig;

    $content =~ s/\s+$//;

    $content;
}

sub clean {
    my ($str) = @_;

    $str =~ s/^\s+//g;
    $str =~ s/\s+$//g;
    $str =~ s/\s+/ /g;

    $str;
}

sub parse_verse {
    my ($content, $num, $comment_map) = @_;
    #my $out = {};
    #$out->{verse_number} = $num;
    my %comment_verse = ();

    ##$content =~ s{✻}{*}g;  # s()() rather than tr()() because char is multi-byte
    # HERE $content =~ s/\x{273B}/*/g;  # unicode tear drop start to ASCII star
    #$content =~ s/\u273B/^/g;
    $content =~ s{<span class="content-newline"><br></span>\s?}{/ }ig;
    $content =~ s{<span class="content-paragraph"><br><br></span>\s?}{\\ }ig;
    $content =~ s{<span class="speaker"><b>([\w\.]+)</b></span>}{<$1>}ig;
    $content =~ s{<span class="speaker">([\w\.]+)\s?</span>}{<$1>}ig;
    $content =~ s{<span class="speaker">(Chorus [\w\.]+)?</span>}{<$1>}ig;
    $content =~ s{<span class="number">17 18</span>\s?}{};
    $content =~ s{<a href="" class="inline-comment" data-comment-id="(\d+)">([^<]+)</a>}{\{[$1] $2\}}ig;

    ##print "COMMENT_MAP: ". YAML::Safe::Dump($comment_map);
    if ($content =~ s|{\[(\d+)\]|"{". $comment_map->{$1}|eg) {
        my $orig_number = $1;
        my $comment_number = $comment_map->{$orig_number};
        #$out->{comments}->{$comment_number}->{verse_number} = $num;
        $comment_verse{$comment_number} = $num;
        $content =~ s[\{(\d+) \*\}][{AVN:INDEX $1}]g;
        #print ">>>>> $orig_number -- $comment_number -- $num\n";
    }

    $content =~ s{\s+\*>}{>}g;

    $content = clean_formatting($content);

    if ($content =~ s{<span class="firstverse">}{@}) {
        $content =~ s{</span>}{};
        #$content = "#$content";
    }

    ($content, \%comment_verse);
}

sub time2iso {
    my ($time) = @_;

    strftime('%Y-%m-%dT%H:%M:%SZ', gmtime($time));
}

sub file_mtime {
    my ($file) = @_;
    my $st = stat($file) or die "No $file: $!";
    $st->mtime;
}

sub gen_provenance {
    my ($dir, $file) = @_;
    my @out = ();
    my $file_time = time2iso(file_mtime("$dir/$file"));
    my $now_time = time2iso(time());

    push(@out, "$file_time - Downloaded from https://catholicbible.online/douay_rheims/$file");
    push(@out, "$now_time - Extracted by program $0");

    \@out;
}

__END__

for my $sec (qw( OT NT )) {
    my $in_parts_dir = "$top_in_dir/$bible/$part";

    for my $in_book (sort (read_dir("$in_dir/$part"))) {
        my $in_dir = "$in_parts_dir/$in_book";
        my $id = $book_info->{'USFM_names'}->{$bible}->{$in_book}
            || die "Can't find USFM ID for $bible/$in_book\n";
        # my $out_dir = "$out_bible_dir/$id";
        # if (! -d $out_dir) {
        #     mkdir($out_dir) || die "Can't mkdir $out_dir: $!\n";
        # }
        #print "B      $in_dir  => $id\n";

        print "    Processing $bible $id from $in_dir\n";

        my $out_file = "$out_bible_dir/$id.yaml";
        my $data = {};
        $data->{book} = $id;
        for my $file (sort _by_ch (read_dir($in_dir))) {
            my $in_file = "$in_dir/$file";
            print "        Reading: $in_file\n";
            if ($file =~ m/ch_(\d+)$/) {
                if (-f "$in_file.MADE_UTF8") {
                    $in_file = "$in_file.MADE_UTF8";
                }
                my $chapter_num = $1;
                # my $out_file = sprintf("$out_dir/%03d.yaml", $chapter_num);
                # print "$in_file  => $out_file\n";


                my $chap_data = parse_verse_file($in_file, $chapter_num, $id);
                $chap_data = final_processing($chap_data, $bible, $id);

                $data->{bible_name} = $chap_data->{bible_name};
                $data->{book_name}  = $chap_data->{book_name};

                delete($chap_data->{bible_id});
                delete($chap_data->{book_id});
                delete($chap_data->{bible_name});
                delete($chap_data->{book_name});


                $data->{chapters}->[$chapter_num] = $chap_data;
                #YAML::Safe::DumpFile($out_file, $data);

                $data->{chapter_count} = $chapter_num;
                

            } else {
                #die "ODD_FILE_NAME: $in_file\n";
            }
        }
        print "        Writing: $out_file\n";
        YAML::Safe::DumpFile($out_file, $data);
    }
}


sub final_processing {
    my ($data, $bible, $book_code) = @_;

    $data->{book_id}  = $book_code;
    $data->{bible_id} = "${bible}_1";
    if ($bible eq 'knox') {
        if ($book_code eq 'JOB') {
            $data->{verses}->[9] =~ s{\*}{<comment=2>};
                #s{\*}{<a href="" class="inline-comment" data-comment-id="822">*</a>};
            $data->{comments}->{2}->{verse_number} = 9;
        } elsif ($book_code eq '2MA') {
            $data->{verses}->[10] =~ s{\*}{<comment=4>};
            $data->{comments}->{4}->{verse_number} = 10;

        }
    }

    if (defined($data->{verses}->[0]) && $data->{verses}->[0] =~ /\S/) {
        my $verse_0 = $data->{verses}->[0];
        my $verse_1 = $data->{verses}->[1];

        $verse_0 =~ s/\@//;
        $verse_0 =~ s{[\s/]+$}{};
        $verse_0 =~ s/^([A-Z0-4]{3}\:\d{1,3})\:0 /${1}:1 /;

        $verse_1 =~ s/^[A-Z0-4]{3}\:\d{1,3}\:1 //;

        $data->{verses}->[1] = "$verse_0 [$verse_1";
        delete ($data->{verses}->[0]);
    } elsif (defined($data->{verses}->[2]) && $data->{verses}->[2] =~ /:2 @/) {
        $data->{verses}->[1] =~ s/:1 @/:1 /;
        $data->{verses}->[2] =~ s/:2 @/:2 /;
        $data->{verses}->[3] =~ s/:3 /:3 [/;
    } elsif (defined($data->{verses}->[1]) && $data->{verses}->[1] =~ /:1 @/) {
        $data->{verses}->[1] =~ s/:1 @/:1 /;
        $data->{verses}->[2] =~ s/:2 /:2 [/;
    }

    #TODO: reactivate this
    # for my $verse_num (0..$data->{last_verse_number}) {
    #     if (my $hash = $data->{verses}->[$verse_num]->{comments}) {
    #         for my $comment_num (sort {$a<=>$b} (keys %{$hash})) {
    #             $data->{comments}->{$comment_num}->{verse_num} = $verse_num;
    #         }
    #         delete($data->{verses}->[$verse_num]->{comments});
    #         #print "!!!!!!! $id -- $num\n";
    #     }
    # }

    # if (defined ($data->{'verses'}->[0]->{'content'})) {
    #     $data->{meta}->{'verse_zero_has_content'} = 'true';
    # }



    $data;
}









